# Meteor. Разрабатываем TODO List.

В данном уроке я не хочу обсуждать, почему метеор убийца веба, тем более я так не считаю, но определенную симпатию к этому фреймворку имею. Поэтому хочу показать с чего можно начать при разработке приложения на нем, какие есть пакеты и вообще что есть такое этот метеор.

Сразу хочу сказать, что у меня нет большого опыта в разработке веб приложений. Я занимаюсь этим всего около двух лет, а с метеором знаком вообще лишь пару месяцев.

Также хочу предупредить, что в данном уроке будут использоваться
следующие технологии для непосредственного написания примера:

* `jade` - html препроцессор;
* `less` - css препроцессор;
* `coffeescript` - язык программирования, компилируемый в javascript.

Небольшая затравка в виде скриншота полученного в ходе урока

![result](https://raw.githubusercontent.com/ovcharik/meteor-getting-started/master/images/result.png)

И кому все еще интересно, добро пожаловать под кат.

+-------------+
| Продолжение |
+-------------+

## Установка Meteor

Сам метеор базируется на `nodejs` и `mongodb`, так же у метеора нет поддержки windows, но они обещают скорым временем это исправить.

Поэтому первым делом устанавливаем [nodejs](http://nodejs.org/download/) и [mongodb](http://www.mongodb.org/downloads).

Следующим шагом необходимо установить метеор. Он не лежит в npm репозитории, поэтому не нужно торопиться и командовать `npm install -g meteor`, в данном случае лишь загрузиться его старая версия, для правильно установки необходимо выполнить в консоли:

    $ curl https://install.meteor.com/ | sh

## Создание проекта

После установки метеора можно сходу командовать

    $ meteor create 'todo-list'
    todo-list: created.

    To run your new app:
       cd todo-list
       meteor
    $ cd todo-list
    $ meteor
    [[[[[ ~/dev/meteor-getting-started/todo-list ]]]]]

    => Started proxy.
    => Started MongoDB.
    => Started your app.

    => App running at: http://localhost:3000/

Данный вывод означает, что все прошло хорошо, и наш хелловорлд можно проверить в браузере.

![helloworld](https://raw.githubusercontent.com/ovcharik/meteor-getting-started/master/images/helloworld.png)


Теперь, после проверки работоспособности нового проекта, файлы, находящиеся в корне проекта, можно удалить, нам они не особо интересны. Также можно заметить что была создана директория `.meteor`, там хранится различная служебная информация о проекте и даже автоматически сгенерируемый `.gitignore`, кстати для ручного управления пакетами можно изменять файл `packages`, но консольные утилиты тоже достаточно удобны.

Если у вас такой же результат как и у меня, значит минимальное окружение для разработки метеор проекта готово, если же что-то пошло не так - проверьте корректность установки `nodejs`, `mongodb` и `meteor`, например, у меня на компьютере сейчас следующая конфигурация:

    $ node -v
    v0.10.33
    $ mongod --version
    db version v2.4.12
    $ meteor --version
    Meteor 1.0

На данном этапе мы закончим с формальностями и приступим к разработке нашего туду листа. Для удобства рекомендую открыть новую вкладку консоли, так как перезапускать наше метеор приложение больше не потребуется, но будем использовать консольный интерфейс фреймворка для установки пакетов.

## Пакеты

Тут я опять же не хочу обсуждать почему в метеоре используется свой пакетный менеджер и почему они любят так велосипедить, к уроку это никакого отношения не имеет.

Установка пакетов производится командой

    $ meteor add <package-name>

Как я писал выше, приложение будем разрабатывать на `less`, `jade` и `coffeescript`, а значит самое время установить их. Все пакеты, используемые в уроке, и кучу других можно найти на сайте [Atmosphere](https://atmospherejs.com/). Собственно названия пакетов:

* `less`, `coffeescript` - это официальные пакеты, поэтому не содержат имя автора;
* `mquandalle:jade` - а вот это не официальный пакет, поэтому название состоит из двух составляющих, но выполнен он хорошо, и никаких проблем при его использовании у меня не возникало.

В пакеты `less` и `coffeescript` встроена поддержка `sourcemap`, поэтому и процесс дебага в браузере будет простым, `sourcemap` поддерживается самим метеором: он предоставляет необходимый api для подключения данного функционала, поэтому нам не придется, что-то специально настраивать.

По ходу разработки мы добавим еще несколько популярных пакетов, и я постараюсь описать назначения каждого. Кстати `jquery` и `underscore` уже включены в метеор, как и множество других пакетов, полный список установленных пакетов, можно посмотреть в файле `./.meteor/versions`, в новосозданном проекте.

## Структура приложения

Теперь, по-моему, самое время разобраться с тем как метеор подключает файлы в проект, и какие способы регуляции этого существуют. Здесь нам не потребуется писать конфигурационные файлы для `grant` или `gulp`, метеор уже позаботился об этом. Для скафолдинга существует [проект](https://github.com/Pent/generator-meteor) для Yeoman, но мне приятнее все создавать в ручную. В предыдущем проекте я использовал следующую структуру папок:

    todo-list/           - корень проекта
    ├── client           - тут будут чисто клиентские файлы
    │   ├── components   - компоненты приложения будут состоять из шаблона 
    │   │                  и скрипта, реализующего его логику
    │   ├── config       - файлы конфигурации
    │   ├── layouts      - базовые шаблоны, не имеющие никакой логики
    │   ├── lib          - различные скрипты, которые могут понадобится на
    │   │                  клиенте
    │   ├── routes       - клиентский роутинг
    │   └── styles       - стили
    ├── collections      - здесь будем хранить модели
    ├── lib              - скрипты, которые могут понадобится везде
    ├── public           - статика, картинки, robots.txt и все такое
    ├── server           - файлы для серверной части приложения
    │   ├── methods      - тут будут серверные методы, типа реста,
    │   │                  только удобнее
    │   ├── publications - расшаривание данных из коллекций
    │   ├── routes       - серверный роутинг, собственно можно будет
    │   │                  контролировать http запросы
    │   └── startup      - инициализация сервера

Но в метеоре нет никаких ограничений на именование папок и файлов, так что можете придумать, любую, удобную для вас структуру. Главное следует помнить о некоторых нюансах:

* все файлы из папки `public` в корне проекта будут доступны пользователям по ссылки из браузера;
* все файлы из папки `server` в корне, доступны только серверной части приложения;
* все файлы из папки `client` в корне, доступны только клиентской части приложения;
* все остальное, что находится в корне, доступно в любой среде;
* файлы в проект подключаются автоматически, по следующим правилам:
  - загрузка начинается с поддиректорий, и первой всегда обрабатывается директория с именем `lib`, далее все папки и файлы загружаются в алфавитном порядке;
  - файлы начинающиеся с `main.` загружаются последними.

Например рассмотрим, как будет загружаться наш проект в браузере: первым делом будут загружены файлы из директории `lib` в корне проекта, далее будет обрабатываться папка `client`, в ней также первым делом загрузятся файлы из `lib`, а потом в алфавитном порядке: `components` -> `config` -> ... -> `styles`. И уже после файлы из папки `collections`. Файлы из папок `public` и `server`, не будут загружены в браузер, но, например, скрипты, хранящиеся в папке `public`, можно подключить через тег `script`, как это мы привыкли делать в других проектах, однако разработчики фреймворка не рекомендуют подобный подход.

Также для регуляции среды выполнения в общих файлах можно воспользоваться следующими конструкциями:

```coffeescript
if Meteor.isClient
  # Код, выполняемый только в браузере
if Meteor.isServer
  # Код, выполняемый только на сервере
```

И для регулирования времени выполнения скриптов мы можем использовать метод `Meteor.startup(<func>)`, в браузере это аналог функции `$` из библиотеки `jQuery`, а на сервере, код в данной функции выполнится сразу же после загрузки всех скриптов. [Подробнее об этих переменных и методах](https://docs.meteor.com/#/full/core).

## Базовый шаблон приложения

Для верстки я буду использовать Bootstrap, да знаю, что он всем приелся, но верстальщик из меня никакой, а с бутстрапом я более менее знаком.

Для этого устанавливаем пакет `mizzao:bootstrap-3`, он самый популярный среди прочих, и думаю при его использовании у нас не должно возникнуть проблем.

Далее создаем в папке `client/layouts` файл `head.jade`. Это будет единственный файл в нашем приложении не имеющий формат шаблона, короче просто опишем шапку, а позже разберем что такое шаблоны.

```jade
//- client/layouts/head.jade
head
  meta(charset='utf-8')
  meta(name='viewport', content='width=device-width, initial-scale=1')
  meta(name='description', content='')
  meta(name='author', content='')

  title Meteor. TODO List.
```

Можно открыть браузер и убедиться, что после добавления файла страница имеет указанный заголовок.

Прежде чем начнем верстать предлагаю провести базовую настройку клиентского роутинга, а чуть позже мы разберем этот момент подробнее. Для роутинга можно воспользоваться популярным решением, имеющим весь необходимый нам функционал. Установим пакет `iron:router` ([репозиторий](https://github.com/EventedMind/iron-router)).

После установки в директории `client/config` создаем файл `router.coffee`, со следующим содержанием:

```coffeescript
# client/config/router.coffee
Router.configure
  layoutTemplate: "application"
```

Очевидно, что здесь мы задаем базовый шаблон для нашего приложения, он будет называться `application`. Поэтому в папке `layouts` создаем файл `application.jade`. В этом файле мы опишем шаблон, некоторую сущность, которая на этапе сборки приложения превратится в код на `javascript`, но для нас он останется кодом на `jade`. Кстати в метеоре используется их собственный усатый шаблонизатор `spacebars` и библиотека `blaze`.

Если коротко, то процесс работы шаблонов выглядит следующим образом (на сколько я понял из документации). Шаблоны `spacebars` компилируются в объект библиотеки `blaze`, которая в последствии будет работать непосредственно с `DOM`. В описании к проекту есть сравнение с другими популярными библиотеками:

* по сравнению с обычными текстовыми шаблонизаторами блейз работает с домом, он не будет заново рендерить весь шаблон, что бы поменять один аттрибут, и у него нет проблем с вложенными шаблонами;
* по сравнению с шаблонами `Ember`, блейз рендерит только изменения, нет нужды в явных дата-байдингах и в описаниях зависимостей между шаблонами;
* по сравнению с шаблонами `angular` и `polymer`, блейз имеет понятный и простой синтаксис, меньший порог входа и вообще не позиционируется как технология будущего, а просто работает;
* по сравнению с `React` имеет простой синтаксис описания шаблонов и простое управление данными.

Это я практически перевел параграф из официального [описания](https://atmospherejs.com/meteor/blaze) библиотеки, так что прошу не кидаться в меня камнями, если с чем-то не согласны. Сам я сталкивался с этими технологиями (кроме `ember`) и в принципе согласен с авторами библиотеки, из минусов в блейзе хочу заметить завязку на метеоре.

Но мы в своем проекте не используем явно ни `blaze`, ни `spacebars`. Для `jade` шаблонов процесс компиляции имеет такую последовательность: `jade` -> `spacebars` -> `blaze`.

Все шаблоны в метеор описываются в теге `template`, где должен быть аттрибут с именем шаблона. Помните, мы в настройках роутера указали `layoutTemplate: "application"`, вот `application`, как раз и является именем шаблона.

Вроде разобрались что такое шаблоны в метеор, самое время сверстать наш шаблон, он будет состоять из шапки и футера.

```jade
//- client/layouts/application.jade
template(name='application')
  nav.navbar.navbar-default.navbar-fixed-top
    .container
      .navbar-header
        button.navbar-toggle.collapsed(
          type='button',
          data-toggle='collapse',
          data-target='#navbar',
          aria-expanded='false',
          aria-controls='navbar'
        )
          span.sr-only Toggle navigation
          span.icon-bar
          span.icon-bar
          span.icon-bar
        a.navbar-brand(href='#') TODO List
      #navbar.collapse.navbar-collapse
        ul.nav.navbar-nav

  .container
    +yield

  .footer
    .container
      p.text-muted TODO List, 2014.
```

Здесь нужно понимать, что это не совсем привычный нам `jade`, с его миксинами, джаваскриптом и инклудами. `Jade` должен скомпилироваться в шаблон `spacebars`, и это накладывает некоторые особенности. От `jade`, можно сказать мы заберем только синтаксис, остальное нам просто не нужно. В данном шаблоне используется конструкция `+yield`, это конструкция означает, что будет вместо нее будет отрендерен шаблон `yield`, это особенность `iron-router`, он автоматически подставит нужный шаблон в зависимости от пути, чуть позже мы займемся роутерами, а сейчас можно внести косметические изменения в верстку и посмотреть на результат.

```less
// client/styles/main.less
html {
  position: relative;
  min-height: 100%;
}

body {
  margin-bottom: 60px;

  & > .container{
    padding: 60px 15px 0;
  }
}

.footer {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: 60px;
  background-color: #f5f5f5;

  .container .text-muted {
    margin: 20px 0;
  }
}
```

При изменениях стилей, кстати не требуется обновлять страницу в браузере, достаточно сохранить файл, и они сразу же применятся, вот такой удобный инструмент из коробки есть для верстальщиков в метеоре.

![my_helloworld](https://raw.githubusercontent.com/ovcharik/meteor-getting-started/master/images/my_helloworld.png)

Давайте посмотрим, что по сути мы сделали, а то слов было сказано достаточно много, а результата особо и не видно. А по сути мы создали одной командой метеор проект, добавили в него несколько пакетов и четыре файла, два из который к метеору отношения практически не имеют. У нас после этих простых операций появилась возможность использовать любимые технологии для написания кода (по крайней мере мои любимые), и клиентский роутинг, с функционалом которого мы еще разберемся. Подобный старт мне сильно напоминает работу с `Ruby on Rails`, только у нас не будет забот о серверной части приложения, а для клиентской у нас есть набор удобных библиотек облегчающих процесс разработки донельзя.

## Роутинг

В самом метеоре нет стандартного механизма роутинга, я предлагаю использовать пакет `iron:router`, он [хорошо документирован](https://github.com/EventedMind/iron-router/blob/devel/Guide.md), активно поддерживается, обладает богатым функционалом и также является самым популярным решениям для роутинга в контексте метеора.

Еще эту библиотеку можно использовать для серверного роутинга. Например, мне, на реальном проекте, это понадобилось для авторизации пользователей, так как основной проект сделан на `Ruby on Rails`, а пользователям нет нужды думать, что это два различных приложения и проходить в них авторизацию дважды. Вообще для серверного роутинга и создания REST api для метеора есть несколько популярных [подходов](http://www.meteorpedia.com/read/REST_API).

Создадим базовые роутеры, чтобы на примере посмотреть как работает данная библиотека и каким функционалом обладает, а позже будем навешивать на них основной функционал.

Для начала зададим ссылки на наши страницы

```jade
//- client/layouts/application.jade
//- ...
#navbar.collapse.navbar-collapse
  ul.nav.navbar-nav
    li
      a(href='/') Home
    li
      a(href='/about') About
```

Создаем контроллеры в папке клиентских роутеров, пока это будут просто заглушки

```coffeescript
# client/routers/home.coffee
Router.route '/',
  name: 'home'
  controller: HomeController

class HomeController extends RouteController

  action: ->
    super()

# client/routers/about.coffee
Router.route '/about',
  name: 'about'
  controller: AboutController

class AboutController extends RouteController

  action: ->
    super()
```

В функцию `Router.route` нужно передать два параметра, первый это путь, причем путь может быть паттерном (например: `/:user/orders/:id/info`), все параметры из паттерна будут доступны в объекте контроллера, через свойство `params`. Вторым параметром передается объект с опциями, что бы вынести всю логику отдельно от простого описания пути и имени, можно создать контроллеры, в нашем случае это простые заглушки.

`Iron-router` попытается автоматически отрендерить шаблон, с именем роута (шаблоны можно указывать явно), создадим их

```jade
//- client/components/home/home.jade
template(name='home')
  h1 Home

//- client/components/about/about.jade
template(name='about')
  h1 About
```

Можно открыть браузер и убедиться, что наш роутинг работает, покликав на ссылки в шапке. Причем работает без обновления страницы.

![base_routing](https://raw.githubusercontent.com/ovcharik/meteor-getting-started/master/images/base_routing.png)

> По ходу разработки данного урока я попытаюсь все изменения в коде вносить в репозиторий, в соответствии последовательности изложения, что бы вы могли проследить весь процесс, так как в посте некоторые вещи могут быть пропущены. [Репозитарий](https://github.com/ovcharik/meteor-getting-started/commits/master).

## Пользователи и аутентификация

Многие технические задания, приходящие к нам в компанию, первой задачей описывают систему пользователей. Так как это довольно распространенная задача, считаю необходимым и в нашем уроке рассмотреть способы аутентификации пользователей, тем более метеор для этого предоставляет стандартные средства.

Мы не будем сильно углубляться в механизмы, а просто используем готовые решения, которые позволят нам создавать пользователей через логин/пароль и авторизацию через сервисы `google` и `github`. Я привык в рельсах настраивать связку `devise` и `omniauth` парой генераторов и несколькими строчками в конфиге. Так вот метеор мало того, что предоставляет это из коробки, так еще и настройка сервисов происходит максимально просто.

Установим следующие пакеты:

* `accounts-base` - базовый пакет для пользователей приложения на метеоре;
* `accounts-password`, `accounts-github`, `accounts-google` - добавим поддержку для аутентификации через логин/пароль и сервисов `github` и `google`;
* `ian:accounts-ui-bootstrap-3` - пакет для упрощения интеграции аккаунтов в приложение на бутстрапе.

Пакет `ian:accounts-ui-bootstrap-3` нам позволит одной строчкой добавить форму аутентификации/регистрации в приложение, а также предоставит интерфейс к настройке сторонних сервисов. [Сам проект](https://github.com/ianmartorell/meteor-accounts-ui-bootstrap-3/), там есть небольшая документация и скриншоты того как выглядит интеграция формы и настройка сервисов.

Модифицируем нашу шапку

```jade
//- client/layouts/application.jade
//- ...
#navbar.collapse.navbar-collapse
  ul.nav.navbar-nav
    li
      a(href='/') Home
    li
      a(href='/about') About
  ul.nav.navbar-nav.navbar-right
    +loginButtons
```

И получим следующий результат

![base_auth_form](https://raw.githubusercontent.com/ovcharik/meteor-getting-started/master/images/base_auth_form.png)

После конфигурации можем убедиться, что в токены авторизации сохранились.

    $ meteor mongo
    MongoDB shell version: 2.4.9
    connecting to: 127.0.0.1:3001/meteor
    meteor:PRIMARY> show collections
    meteor_accounts_loginServiceConfiguration
    meteor_oauth_pendingCredentials
    system.indexes
    users
    meteor:PRIMARY> db.meteor_accounts_loginServiceConfiguration.find()
    {
      "service" : "github",
      "clientId" : "<id>",
      "secret" : "<secret>",
      "_id" : "AjKrfCXAioLs7aBTN"
    }
    {
      "service" : "google",
      "clientId" : "<id>",
      "secret" : "<secret>",
      "_id" : "HaERjHLYmAAhehskY"
    }

Сконфигурируем нашу систему пользователей, так как я хочу настроить верификацию адреса электронной почты, необходимо настроить `smtp`, кстати для отправки email используется пакет `email`. Он не входит в стандартный набор метеора, поэтому его необходимо установить вручную, если вам нужна работа с почтой.

```coffeescript
# server/config/smtp/coffee
smtp =
  username: "meteor-todo-list@yandex.ru"
  password: "meteor-todo-list1234"
  server:   "smtp.yandex.ru"
  port:     "587"

# Экранируем символы
_(smtp).each (value, key) -> smtp[key] = encodeURIComponent(value)

# Шаблон url доступа к smtp
url = "smtp://#{smtp.username}:#{smtp.password}@#{smtp.server}:#{smtp.port}"

# Задаем переменную окружения, метеор будет использовать данные из нее
process.env.MAIL_URL = url
```

И сконфигурируем аккаунты, что бы метеор запрашивал подтверждение адреса электронной почты.

```coffeescript
# server/config/accounts.coffee
emailTemplates =
  from: 'TODO List <meteor-todo-list@yandex.ru>'
  siteName: 'Meteor. TODO List.'

# Заменяем стандартные настройки для почты
_.deepExtend Accounts.emailTemplates, emailTemplates

# Включаем верификацию
Accounts.config
  sendVerificationEmail: true
```

В нашем приложении не будет возможности подключать несколько сервисов к одному аккаунту, так как это требует тонкой настройки. Возможно скоро в метеоре проработают данный момент, но пока существует готовое, более менее нормальное, решение `mondora:connect-with`, но оно еще сырое. Можно попытаться самим мержить аккаунты, в этом нет ничего сложного, и в сети есть множество примеров и других решений: [раз](https://atmospherejs.com/mondora/connect-with), [два](http://www.meteorpedia.com/read/Merging_OAuth_accounts), [три](http://stackoverflow.com/questions/18358007/using-meteor-accounts-package-to-link-multiple-services).

Также по аккаунтам есть подробная [документация](https://docs.meteor.com/#/full/accounts_api), мы всего лишь поставили пакеты и видим магию, но под капотом это происходит не многим сложнее.

Следующим шагом мы займемся страницей пользователя, но прежде чем преступить необходимо рассмотреть как реализованы некоторые вещи в метеоре.

> Не стоит меня сильно пинать, за то что так поверхностно рассмотрел систему аккаунтов, просто хотел показать что в ней нет ничего сложного. На подробное рассмотрение потребуется отдельный пост. А мы в уроке создали необходимый базовый функционал и можем продолжить идти к конечному результату.

# Коллекции, публикации, подписки и защита данных.

При создании проекта, автоматически были добавлены два пакета `autopublish` и `insecure`, так вот сейчас самое время от них избавиться, так как они предоставляет пользователю безграничный доступ ко всем коллекциям в бд, и их можно использовать только для прототипирования. Удаляются пакеты командой

    $ meteor remove <package-name>

### Коллекции

Коллекции в метеоре можно сравнить с коллекциями в монге, собственно они на них и подписываются, у них также есть методы `find`, `insert`, `update`, `upsert` (агрегацию можно организовать на сервере при помощи пакета `zvictor:mongodb-server-aggregation`). Одна из коллекций у нас уже создана и доступ к ней можно получить через `Meteor.users`, например, попробуйте выполнить в консоли браузера `Meteor.users.findOne()`. Здесь важно отметить, что все данные коллекций кешируются в браузере, и если выполнить миллион раз в цикле на клиенте `Meteor.users.find(options).fetch()`, то ничего кроме браузера вы не нагрузите. Это достигается при помощи библиотеки `minimongo`, которая достаточно умная, что бы делать выборку в зависимости от переданных параметров на клиенте.

С голыми данными не очень приятно работать, хотелось бы добавить бизнес-логику в объекты коллекции, это можно сделать при помощи функции `_transform` у коллекции, в которую передаются объекты после получения их с сервера и там их уже можно обработать, однако чтобы не вникать в эти тонкости, можно воспользоваться пакетом `dburles:collection-helpers`, который к коллекции добавляет метод `helpers`, куда можно передать объект, от которого будут наследоваться все данные.

Установим пакет, и напишем метод возвращающий `email` в зависимости от сервиса, используемого при регистрации. Также при создании пользователя я добавил вычисляемое поле с ссылкой на аватар пользователя в сервисе [Gravatar](http://ru.gravatar.com/) - добавим метод который сможет возвращать эту ссылку с некоторыми параметрами.

```coffeescript
# collections/users.coffee
Users = Meteor.users

# Добавляем методы и свойства в модель
Users.helpers
  getEmails: ->
    s = _(@services).map (value, key) -> value?.email
    e = _(@emails).map (value, key) -> value?.address
    _.compact e.concat(s)

  getEmail: ->
    @getEmails()[0]

  getAvatar: (size = 200, def = 'identicon') ->
    throw 'Only client method' if Meteor.isServer
    durl = "http://www.gravatar.com/avatar/00000000000000000000000000000000"
    url = @profile?.avatar || durl
    options =
      s: size
      d: def
      r: 'g'
    url + "?" + $.param(options)

# Экспорт коллекции
@UsersCollection = Users
```

Вроде разобрались, что такое коллекции в метеоре, следует упомянуть, что нежелательно хранить состояния в модели, так как все данные в коллекции реактивны, если изменится запись в бд, то сохраненный где-то в памяти, объект модели потеряет свою актуальность, и последующая работа с ним может привести нас к использованию устаревших данных, позже на примерах рассмотрим, как можно работать с моделями.

Я создал три записи пользователя в бд

    $ meteor mongo
    MongoDB shell version: 2.4.9
    connecting to: 127.0.0.1:3001/meteor
    meteor:PRIMARY> db.users.count()
    3
    meteor:PRIMARY>

А когда пытаюсь получить данные в браузере, то не нашел ни одной записи без аутентификации и одну (собственную) в противном случае.

![fail_publish](https://raw.githubusercontent.com/ovcharik/meteor-getting-started/master/images/fail_publish.png)

В данном приложении не будем скрывать пользователей от всех, просто скроем приватную информацию, вроде токенов аутентификации.

### Публикации

